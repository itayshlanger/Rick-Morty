stages:
  - build
  - deploy
  - test

variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  KUBECONFIG: $HOME/.kube/config 

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $IMAGE_TAG app/.
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker push $IMAGE_TAG

deploy_to_cluster:
  stage: deploy
  image: bitnami/kubectl:latest
  before_script:
    - export KUBECONFIG=$KUBECONFIG  # Ensure the Kubernetes config is used
  tags: 
    - rick-and-morty
  script:
    - kubectl get nodes  # Verify connection to the cluster
    - 'sed -i "s|image: .*|image: ${IMAGE_TAG}|g" yamls/deployment.yaml'
    - kubectl apply -f yamls/
    - kubectl rollout status deployment/rick-and-morty-api
  dependencies:
    - build

test_application:
  stage: test
  image: curlimages/curl:latest
  tags: 
    - rick-and-morty
  script:
    - |
      EXTERNAL_IP=""
      for i in {1..10}; do
        EXTERNAL_IP=$(kubectl get svc rick-and-morty-api -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        [ -n "$EXTERNAL_IP" ] && break || sleep 5
      done
      echo "Service External IP: $EXTERNAL_IP"
      curl -f http://$EXTERNAL_IP/healthcheck || exit 1
  dependencies:
    - deploy_to_cluster
